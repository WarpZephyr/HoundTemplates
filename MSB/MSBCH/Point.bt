//------------------------------------------------
//--- 010 Editor v15.0.2 Binary Template
//
//      File: Point.bt
//   Authors: WarpZephyr
//   Version: 1.0.0
//   Purpose: Chromehounds MSB Points.
//  Category: Maps
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

enum <short> PointType
{
    PointTypeBounds = 0,
    PointTypeLocal = 1,
    PointTypeSound = 2,
    PointTypeMineField = 3,
    PointTypeGoal = 4,
    PointTypeBattleField = 5,
    PointTypeSnipeArea = 6,
    PointTypeGarage = 7,
    PointTypeEnvCtrl = 8
};

enum <short> ShapeType
{
    ShapeTypeNone = -1,
    ShapeTypePoint = 0,
    ShapeTypeCircle = 1,
    ShapeTypeSphere = 2,
    ShapeTypeCylinder = 3,
    ShapeTypeRect = 4,
    ShapeTypeBox = 5,
    ShapeTypeComposite = 6,
};

// PointType Structs
//------------------------------------------------

typedef struct
{
    int unk00 <hidden=true>; Assert(unk00 == 0);
    int unk04 <hidden=true>; Assert(unk04 == 0);
    int unk08 <hidden=true>; Assert(unk08 == 0);
    int unk0C <hidden=true>; Assert(unk0C == 0);
    int unk10 <hidden=true>; Assert(unk10 == 0);
    int unk14 <hidden=true>; Assert(unk14 == 0);
    int unk18 <hidden=true>; Assert(unk18 == 0);
    int unk1C <hidden=true>; Assert(unk1C == 0);
} PointLocal;

typedef struct
{
    int id;
    float unk04;
    ubyte unk08;
    ubyte unk09 <hidden=true>; Assert(unk09 == 0);
    ubyte unk0A <hidden=true>; Assert(unk0A == 0);
    ubyte unk0B <hidden=true>; Assert(unk0B == 0);
    int unk0C <hidden=true>; Assert(unk0C == 0);
    int unk10 <hidden=true>; Assert(unk10 == 0);
    int unk14 <hidden=true>; Assert(unk14 == 0);
    int unk18 <hidden=true>; Assert(unk18 == 0);
    byte unk1C;
    ubyte unk1D <hidden=true>; Assert(unk1D == 0);
    ubyte unk1E <hidden=true>; Assert(unk1E == 0);
    ubyte unk1F <hidden=true>; Assert(unk1F == 0);
    int unk20 <hidden=true>; Assert(unk20 == 0);
    int unk24 <hidden=true>; Assert(unk24 == 0);
    int unk28 <hidden=true>; Assert(unk28 == 0);
    int unk2C <hidden=true>; Assert(unk2C == 0);
    int unk30 <hidden=true>; Assert(unk30 == 0);
    int unk34 <hidden=true>; Assert(unk34 == 0);
    int unk38 <hidden=true>; Assert(unk38 == 0);
    int unk3C <hidden=true>; Assert(unk3C == 0);
} PointSound;

typedef struct
{
    short unk00;
    short unk02;
    int unk04 <hidden=true>; Assert(unk04 == 0);
    int unk08 <hidden=true>; Assert(unk08 == 0);
    int unk0C <hidden=true>; Assert(unk0C == 0);
} PointMineField;

typedef struct
{
    int unk00;
    int unk04 <hidden=true>; Assert(unk04 == 0);
    int unk08 <hidden=true>; Assert(unk08 == 0);
    int unk0C <hidden=true>; Assert(unk0C == 0);
    int unk10 <hidden=true>; Assert(unk10 == 0);
    int unk14 <hidden=true>; Assert(unk14 == 0);
    int unk18 <hidden=true>; Assert(unk18 == 0);
    int unk1C <hidden=true>; Assert(unk1C == 0);
} PointGoal;

typedef struct
{
    ubyte unk00;
    ubyte unk01; Assert(unk01 == 0);
    ubyte unk02; Assert(unk02 == 0);
    ubyte unk03; Assert(unk03 == 0);
    int unk04 <hidden=true>; Assert(unk04 == 0);
    int unk08 <hidden=true>; Assert(unk08 == 0);
    int unk0C <hidden=true>; Assert(unk0C == 0);
    int unk10 <hidden=true>; Assert(unk10 == 0);
    int unk14 <hidden=true>; Assert(unk14 == 0);
    int unk18 <hidden=true>; Assert(unk18 == 0);
    int unk1C <hidden=true>; Assert(unk1C == 0);
} PointSnipeArea;

typedef struct
{
    int unk00;
    short unk04;
    short unk06;
    short unk08;
    short unk0A;
    short unk0C;
    short unk0E <hidden=true>; Assert(unk0E == 0);
    int unk10 <hidden=true>; Assert(unk10 == 0);
    int unk14 <hidden=true>; Assert(unk14 == 0);
    int unk18 <hidden=true>; Assert(unk18 == 0);
    int unk1C <hidden=true>; Assert(unk1C == 0);
} PointGarage;

typedef struct
{
    ubyte unk00;
    ubyte unk01;
    short unk02;
    int unk04 <hidden=true>; Assert(unk04 == 0);
    int unk08 <hidden=true>; Assert(unk08 == 0);
    int unk0C <hidden=true>; Assert(unk0C == 0);
    int unk10 <hidden=true>; Assert(unk10 == 0);
    int unk14 <hidden=true>; Assert(unk14 == 0);
    int unk18 <hidden=true>; Assert(unk18 == 0);
    int unk1C <hidden=true>; Assert(unk1C == 0);
} PointEnvCtrl;

// Sub Structs
//------------------------------------------------

typedef struct
{
    short count;
    if (count > 0)
    {
        short pointIndexes[count];
    }
    
    Align(4);
} PointLinkPrevious;

typedef struct
{
    short count;
    if (count > 0)
    {
        short pointIndexes[count];
    }
    
    Align(4);
} PointLinkNext;

// Main Struct
//------------------------------------------------

typedef struct
{
    local quad start <hidden=true> = FTell();
    
    // Read Data
    int nameOffset; Assert(nameOffset > 0);
    PointType pointType;
    short id;
    ShapeType shapeType;
    short unk0A;
    Vector3 position;
    Vector3 rotation;
    short unk24;
    short unk26;
    int linkPreviousOffset; Assert(linkPreviousOffset > 0);
    int linkNextOffset; Assert(linkNextOffset > 0);
    short layerID;
    short unk32;
    int unk34 <hidden=true>; Assert(unk34 == 0);
    int unk38 <hidden=true>; Assert(unk38 == 0);
    int unk3C <hidden=true>; Assert(unk3C == 0);
    int unk40 <hidden=true>; Assert(unk40 == 0);
    int unk44 <hidden=true>; Assert(unk44 == 0);
    int unk48 <hidden=true>; Assert(unk48 == 0);
    int unk4C <hidden=true>; Assert(unk4C == 0);
    int unk50 <hidden=true>; Assert(unk50 == 0);
    int shapeDataOffset;
    int offsetSound;
    int offsetMineField;
    int offsetLocal;
    int offsetGoal;
    int offsetSnipeArea;
    int offsetGarage;
    int offsetEnvCtrl;
    int offset74 <hidden=true>; Assert(offset74 == 0);
    int offset78 <hidden=true>; Assert(offset78 == 0);
    int offset7C <hidden=true>; Assert(offset7C == 0);
    
    // Get Offset Structs
    FSeek(start + nameOffset);
    string name;
    
    FSeek(start + linkPreviousOffset);
    PointLinkPrevious linkPrevious;
    
    FSeek(start + linkNextOffset);
    PointLinkNext linkNext;

    if (shapeDataOffset > 0)
    {
        Assert(shapeType != ShapeTypePoint);
        FSeek(start + shapeDataOffset);
        switch (shapeType)
        {
            case ShapeTypeCircle: ShapeCircle circle; break;
            case ShapeTypeSphere: ShapeSphere sphere; break;
            case ShapeTypeCylinder: ShapeCylinder cylinder; break;
            case ShapeTypeRect: ShapeRect rect; break;
            case ShapeTypeBox: ShapeBox box; break;
            case ShapeTypeComposite: ShapeComposite composite; break;
            default: Assert(false, Str("Unknown shape type: %d", shapeType));
        }
    }
    
    switch (pointType)
    {
        case PointTypeLocal:
            Assert(offsetLocal > 0);
            Assert(offsetSound == 0);
            Assert(offsetMineField == 0);
            Assert(offsetGoal == 0);
            Assert(offsetSnipeArea == 0);
            Assert(offsetGarage == 0);
            Assert(offsetEnvCtrl == 0);
            FSeek(start + offsetLocal);
            PointLocal loc;
            break;
        case PointTypeSound:
            Assert(offsetLocal == 0);
            Assert(offsetSound > 0);
            Assert(offsetMineField == 0);
            Assert(offsetGoal == 0);
            Assert(offsetSnipeArea == 0);
            Assert(offsetGarage == 0);
            Assert(offsetEnvCtrl == 0);
            FSeek(start + offsetSound);
            PointSound sound;
            break;
        case PointTypeMineField:
            Assert(offsetLocal == 0);
            Assert(offsetSound == 0);
            Assert(offsetMineField > 0);
            Assert(offsetGoal == 0);
            Assert(offsetSnipeArea == 0);
            Assert(offsetGarage == 0);
            Assert(offsetEnvCtrl == 0);
            FSeek(start + offsetMineField);
            PointMineField mineField;
            break;
        case PointTypeGoal:
            Assert(offsetLocal == 0);
            Assert(offsetSound == 0);
            Assert(offsetMineField == 0);
            Assert(offsetGoal > 0);
            Assert(offsetSnipeArea == 0);
            Assert(offsetGarage == 0);
            Assert(offsetEnvCtrl == 0);
            FSeek(start + offsetGoal);
            PointGoal goal;
            break;
        case PointTypeSnipeArea:
            Assert(offsetLocal == 0);
            Assert(offsetSound == 0);
            Assert(offsetMineField == 0);
            Assert(offsetGoal == 0);
            Assert(offsetSnipeArea > 0);
            Assert(offsetGarage == 0);
            Assert(offsetEnvCtrl == 0);
            FSeek(start + offsetSnipeArea);
            PointSnipeArea snipeArea;
            break;
        case PointTypeGarage:
            Assert(offsetLocal == 0);
            Assert(offsetSound == 0);
            Assert(offsetMineField == 0);
            Assert(offsetGoal == 0);
            Assert(offsetSnipeArea == 0);
            Assert(offsetGarage > 0);
            Assert(offsetEnvCtrl == 0);
            FSeek(start + offsetGarage);
            PointGarage garage;
            break;
        case PointTypeEnvCtrl:
            Assert(offsetLocal == 0);
            Assert(offsetSound == 0);
            Assert(offsetMineField == 0);
            Assert(offsetGoal == 0);
            Assert(offsetSnipeArea == 0);
            Assert(offsetGarage == 0);
            Assert(offsetEnvCtrl > 0);
            FSeek(start + offsetEnvCtrl);
            PointEnvCtrl envCtrl;
            break;
        case PointTypeBounds:
        case PointTypeBattleField:
            Assert(offsetLocal == 0);
            Assert(offsetSound == 0);
            Assert(offsetMineField == 0);
            Assert(offsetGoal == 0);
            Assert(offsetSnipeArea == 0);
            Assert(offsetGarage == 0);
            Assert(offsetEnvCtrl == 0);
            break;
        default: Assert(false, Str("Unknown point type: %d", pointType));
    }
} Point <read=ReadPoint>;

string ReadPoint(Point& point)
{
    local string shape <hidden=true>;
    local string type <hidden=true>;
    local string name <hidden=true> = "";

    switch (point.shapeType)
    {
        case ShapeTypeNone: shape = "NoShape"; break;
        case ShapeTypePoint: shape = "Point"; break;
        case ShapeTypeCircle: shape = "Circle"; break;
        case ShapeTypeSphere: shape = "Sphere"; break;
        case ShapeTypeCylinder: shape = "Cylinder"; break;
        case ShapeTypeRect: shape = "Rect"; break;
        case ShapeTypeBox: shape = "Box"; break;
        case ShapeTypeComposite: shape = "Composite"; break;
        default: shape = "UnknownShape";
    }

    switch (point.pointType)
    {
        case PointTypeBounds: type = "Bounds"; break;
        case PointTypeLocal: type = "Local"; break;
        case PointTypeSound: type = "Sound"; break;
        case PointTypeMineField: type = "MineField"; break;
        case PointTypeGoal: type = "Goal"; break;
        case PointTypeBattleField: type = "BattleField"; break;
        case PointTypeSnipeArea: type = "SnipeArea"; break;
        case PointTypeGarage: type = "Garage"; break;
        case PointTypeEnvCtrl: type = "EnvCtrl"; break;
        default: type = "UnknownType";
    }
    
    if (point.name != name)
    {
        name = " | " + point.name;
    }
    
    return Str("ID: %d | %s | %s%s", point.id, shape, type, name);
}
